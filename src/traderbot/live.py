"""Live trading helpers that integrate with Alpaca's API."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Union
import time

import pandas as pd

from .config import TradingConfig
from .strategies import MovingAverageCrossStrategy


@dataclass
class AlpacaPaperTrader:
    """Execute signals generated by a strategy on Alpaca."""

    config: TradingConfig

    def __post_init__(self) -> None:
        try:
            from alpaca.data.historical import StockHistoricalDataClient
            from alpaca.data.requests import StockBarsRequest
            from alpaca.data.timeframe import TimeFrame
            from alpaca.trading.client import TradingClient
            from alpaca.trading.enums import OrderSide, TimeInForce
            from alpaca.trading.requests import MarketOrderRequest
        except ImportError as exc:  # pragma: no cover - optional dependency
            raise ImportError(
                "alpaca-py is required for live trading. Install it with "
                "pip install traderbot[live]"
            ) from exc

        self.config.require_alpaca_credentials()

        self._trading_client = TradingClient(
            self.config.alpaca_api_key,
            self.config.alpaca_secret_key,
            paper=self.config.use_paper,
        )
        self._data_client = StockHistoricalDataClient(
            self.config.alpaca_api_key,
            self.config.alpaca_secret_key,
        )
        self._bars_request = StockBarsRequest
        self._timeframe_cls = TimeFrame
        self._market_order = MarketOrderRequest
        self._order_side = OrderSide
        self._time_in_force = TimeInForce

    def _coerce_timeframe(self, timeframe: Union[str, "TimeFrame"]) -> "TimeFrame":
        if isinstance(timeframe, str):
            lookup = {
                "1min": self._timeframe_cls.Minute,
                "5min": self._timeframe_cls(5, "Min"),
                "15min": self._timeframe_cls(15, "Min"),
                "1h": self._timeframe_cls.Hour,
                "1day": self._timeframe_cls.Day,
            }
            key = timeframe.lower()
            if key not in lookup:
                raise ValueError(f"Unsupported timeframe: {timeframe}")
            return lookup[key]
        return timeframe

    def fetch_recent_bars(
        self,
        limit: int = 200,
        timeframe: Union[str, "TimeFrame"] = "1Day",
    ) -> pd.DataFrame:
        timeframe_obj = self._coerce_timeframe(timeframe)
        request = self._bars_request(
            symbol_or_symbols=self.config.symbol,
            timeframe=timeframe_obj,
            limit=limit,
        )
        bars = self._data_client.get_stock_bars(request)
        frame = bars.df
        if isinstance(frame.index, pd.MultiIndex):
            frame = frame.xs(self.config.symbol, level="symbol")
        return frame[["open", "high", "low", "close", "volume"]]

    def current_position_quantity(self) -> int:
        positions = self._trading_client.get_all_positions()
        for position in positions:
            if position.symbol == self.config.symbol:
                return int(float(position.qty))
        return 0

    def submit_market_order(self, quantity: int, side: str) -> None:
        side_enum = self._order_side.BUY if side.lower() == "buy" else self._order_side.SELL
        order = self._market_order(
            symbol=self.config.symbol,
            qty=abs(int(quantity)),
            side=side_enum,
            time_in_force=self._time_in_force.DAY,
        )
        self._trading_client.submit_order(order)

    def rebalance_to_signal(self, signal: int, price: float) -> Optional[int]:
        current_qty = self.current_position_quantity()
        if signal <= 0 and current_qty > 0:
            self.submit_market_order(current_qty, "sell")
            return -current_qty

        if signal > 0:
            account = self._trading_client.get_account()
            buying_power = float(account.cash)
            target_qty = int(buying_power // price)
            delta = target_qty - current_qty
            if delta > 0:
                self.submit_market_order(delta, "buy")
                return delta
            if delta < 0:
                self.submit_market_order(abs(delta), "sell")
                return delta
        return None

    def run(
        self,
        strategy: Optional[MovingAverageCrossStrategy] = None,
        timeframe: Union[str, "TimeFrame"] = "1Day",
        lookback: int = 200,
        max_iterations: Optional[int] = None,
        sleep: bool = True,
    ) -> None:
        if strategy is None:
            strategy = MovingAverageCrossStrategy(
                fast_window=self.config.fast_window,
                slow_window=self.config.slow_window,
            )

        iterations = 0
        while max_iterations is None or iterations < max_iterations:
            data = self.fetch_recent_bars(limit=lookback, timeframe=timeframe)
            signals = strategy.generate_signals(data["close"])
            latest_signal = int(signals["signal"].iloc[-1])
            latest_price = float(data["close"].iloc[-1])
            self.rebalance_to_signal(latest_signal, latest_price)

            iterations += 1
            if sleep and (max_iterations is None or iterations < max_iterations):
                time.sleep(self.config.poll_interval)


__all__ = ["AlpacaPaperTrader"]
